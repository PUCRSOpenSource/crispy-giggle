\section{Análise dos Resultados}

\subsection{Análise do balanceamento de carga}

Na versão mais simples do programa, a carga não é igualmente balanceada, sendo todo o trabalho feito nas folhas da árvore, deixando os outros nodos inativos na maior parte do tempo. Com os casos de testes propostos, por contar com árvores de processamento que formam uma árvore binária cheia, apenas (n + 1) / 2 processos estão efetivamente trabalhando, enquanto os outros estarão ociosos.

Na versão com ordenação local, existe uma tentativa de balancear a carga mais igualitáriamente. Em cada nodo não folha, o vetor é dividido em 3 partes iguais, uma para ser ordenada localmente e as outras para serem ordenadas pelos nodos inferiores. Dessa forma a carga fica muito mais bem balanceada que na versão anterior, mas ainda não é completamente igualitário, pois existe o tempo de merge dos vetores ordenados pelos filhos, que é uma carga extra que os processos têm que assumir, que é maior o mais próximo esse processo se encontra da raíz.

\subsection{Análise do ganho obtido com hyperthreading}

Precisa dos resultados

\subsection{Análise do ganho obtido com a inclusão de um percentual para ordenação local}

Incluir um percentual para ordenação local permitiu um balanceamento melhor da carga do programa, trazendo um melhor aproveitamento dos processos e uma melhor eficiência do programa. Enquanto na versão simples do programa, apenas em torno da metade dos processos estavam realmente trabalhando fazendo a ordenação, enquanto o resto ficava ocioso esperando pelo resultado, utilizando um percentual local todos os processos trabalham na ordenação, minimizando o tempo ocioso ao máximo. Além disso é possível dividir os vetores a serem ordenados em pedaços menores, pois a cada nível da árvore os nodos dividem o vetor em três para passar adiante, ao invés de dois, isso causa uma melhoria na execução, pois ordenar vários vetores menores trazem um ganho de desempenho sobre ordenar um vetor maior.